module Main where
import System.Environment ; import System.IO
import Control.Arrow      ; import Control.Monad
import Data.Map (Map)     ; import qualified Data.Map as Map
import Data.Maybe         ; import Data.Function (fix)
import Data.Generics

import Language.C                 -- simple API
import Language.C.Analysis        -- analysis API
import Language.C.System.GCC      -- preprocessor used
import Language.C.Analysis.Export -- [starting point for exporting SemRep to AST]

main :: IO ()
main = do
    let usage = error "Example Usage: ./ScanFile -I/usr/include my_file.c"
    args <- getArgs
    when (length args < 1) usage
    let (opts,c_file) = (init &&& last) args

    let compiler = newGCC "gcc" 
    ast <- parseFile compiler Nothing opts c_file >>= checkResult "[parsing]"
    
    (globals,warnings) <- (runTrav_ >>> checkResult "[analysis]") $ analyseAST ast
    mapM (hPutStrLn stderr . show) warnings
    
    putStrLn $ pretty (generateSizeTests c_file globals)
    where
    checkResult :: (Show a) => String -> (Either a b) -> IO b
    checkResult label = either (error . (label++) . show) return

ni :: NodeInfo
ni = mkUndefNodeInfo
generateSizeTests :: FilePath -> GlobalDecls -> CTranslUnit
generateSizeTests c_file globals = 
      flip CTranslUnit ni $
      -- define all neccessary composite type
      map defineComp referenced_comps
      ++
      [ genSizeTest (Map.elems comps_of_interest) ]
    where
    comps = Map.mapMaybe fromComp (gTags globals)
    comps_of_interest  = compsOfInterest c_file comps
    referenced_comps   = computeRefClosure comps comps_of_interest
    fromComp (CompTag struct_union) = Just struct_union
    fromComp (EnumTag _) = Nothing

    
compsOfInterest :: FilePath -> Map SUERef CompType -> Map SUERef CompType
compsOfInterest c_file = Map.filterWithKey isNamed . Map.filter isInCFile
    where
    isInCFile = ((==c_file) . fileOfNode)
    isNamed sue_ref _ =  case sue_ref of AnonymousType _ -> False; _ -> True

-- a small fixpoint algorithm to find the correct order and all references
computeRefClosure :: Map SUERef CompType -> Map SUERef CompType -> [CompType]
computeRefClosure all_comps initial_comps = 
    fixCont addReferenced ([], Map.elems initial_comps, (Map.empty,Map.empty))
    where
    fixCont f = fix $ \close args -> 
        let args'@(result',todo',_) = f args in (if null todo' then reverse result' else close args')
    addReferenced (result,[],ms) = (result,[],ms)
    addReferenced (result,(t:ts),(visit,enter)) | Map.member (sueRef t) enter = (result,ts,(visit,enter))
                                                | Map.member (sueRef t) visit = 
                                                (t:result,ts,(visit,Map.insert (sueRef t) t enter))
                                                | otherwise = 
        let refd = referenced t in (result, refd++(t:ts), (Map.insert (sueRef t) t visit,enter))
    referenced (CompType _ _ members _ _) = mapMaybe getRefdComp members
    getRefdComp memberDecl = fromDirectType (declType memberDecl) >>= fromCompTy
    fromCompTy (TyComp (CompTypeDecl ref _ _)) 
        | (Just r) <- Map.lookup ref all_comps = Just r
        | otherwise = error $ "Internal Error: Could not find definition for "++show ref
    fromCompTy _ = Nothing
    fromDirectType (DirectType tyname _ _) = Just tyname
    fromDirectType (TypeDefType (TypeDefRef _ ref _)) = (fromDirectType.fromJust) ref
    fromDirectType _ = Nothing

defineComp :: CompType -> CExtDecl
defineComp ty = CDeclExt (CDecl (map CTypeSpec (exportCompType $ derefTypeDefs ty)) [] ni)
    where
    derefTypeDefs ty = everywhere (mkT derefTypeDef) ty
    derefTypeDef (TypeDefType (TypeDefRef _ (Just ty) _)) = ty
    derefTypeDef ty = ty
    
-- This is were we'd like to have quasi-quoting.
-- For now, as we lack any code generation facilies, we'll parse a string :)
genSizeTest :: [CompType] -> CExtDecl
genSizeTest tys = either (error.show) fromExtDecl $
                  parseC (inputStreamFromString test) (Position "<autogenerated>" 1 1) 
    where
    fromExtDecl (CTranslUnit [decl] _ ) = decl
    fromExtDecl (CTranslUnit decls _) = error $ "Expected one declaration, but found: "++show (length decls)
    test = "int main() {" ++ concatMap checkSize tys ++ "}"
    checkSize (CompType sue_ref tag _ _ _) = "printf(\"%d\\n\",sizeof("++show tag ++ " " ++ show sue_ref ++")); ";
    

compileAndRunAST _ _ file = 
    case file of
        (CTranslUnit decls _) -> mapM_ (print . pretty) decls
